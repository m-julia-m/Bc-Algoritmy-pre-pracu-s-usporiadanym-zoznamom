%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital,     %% The `digital` option enables the default options for the
               %% digital version of a document. Replace with `printed`
               %% to enable the default options for the printed version
               %% of a document.
%%  color,       %% Uncomment these lines (by removing the %% at the
%%               %% beginning) to use color in the printed version of your
%%               %% document
  oneside,     %% The `oneside` option enables one-sided typesetting,
               %% which is preferred if you are only going to submit a
               %% digital version of your thesis. Replace with `twoside`
               %% for double-sided typesetting if you are planning to
               %% also print your thesis. For double-sided typesetting,
               %% use at least 120 g/m² paper to prevent show-through.
  nosansbold,  %% The `nosansbold` option prevents the use of the
               %% sans-serif type face for bold text. Replace with
               %% `sansbold` to use sans-serif type face for bold text.
  nocolorbold, %% The `nocolorbold` option disables the usage of the
               %% blue color for bold text, instead using black. Replace
               %% with `colorbold` to use blue for bold text.
  lof,         %% The `lof` option prints the List of Figures. Replace
               %% with `nolof` to hide the List of Figures.
  lot,         %% The `lot` option prints the List of Tables. Replace
               %% with `nolot` to hide the List of Tables.
]{fithesis4}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=slovak, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, german, russian, czech, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    department  = Fakulta informatiky,
    author      = Júlia Michálková,
    gender      = f,
    advisor     = {Prof. RNDr. Ivana Černá, CSc.},
    title       = {Algoritmy pre prácu s usporiadaným zoznamom},
    TeXtitle    = {Algoritmy pre~prácu s~usporiadaným zoznamom},
    keywords    = {keyword1, keyword2, ...},
    TeXkeywords = {keyword1, keyword2, \ldots},
    abstract    = {%
      This is the abstract of my thesis, which can

      span multiple paragraphs.
    },
    thanks      = {%
      These are the acknowledgements for my thesis, which can

      span multiple paragraphs.
    },
    bib         = my-bibliography.bib,
    %% Remove the following line to use the JVS 2018 faculty logo.
    facultyLogo = fithesis-fi,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
\usepackage[acronym]{glossaries}          %% The `glossaries` package
\renewcommand*\glspostdescription{\hfill} %% contains helper commands
\loadglsentries{example-terms-abbrs.tex}  %% for typesetting glossaries
\makenoidxglossaries                      %% and lists of abbreviations.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{listings} %% Source code highlighting
\usepackage{indentfirst} %% Added by me Julka
\usepackage[ruled, vlined]{algorithm2e}

\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
\usepackage[babel]{csquotes} %% Context-sensitive quotation marks
\begin{document}
%% Uncomment the following lines (by removing the %% at the beginning)
%% and to print out List of Abbreviations and/or Glossary in your
%% document. Titles for these tables can be changed by replacing the
%% titles `Abbreviations` and `Glossary`, respectively.
%% \clearpage
%% \printnoidxglossary[title={Abbreviations}, type=\acronymtype]
%% \printnoidxglossary[title={Glossary}]

%% The \chapter* command can be used to produce unnumbered chapters:
\chapter*{Úvod}
%% Unlike \chapter, \chapter* does not update the headings and does not
%% enter the chapter to the table of contents. I we want correct
%% headings and a table of contents entry, we must add them manually:
\markright{\textsc{Úvod}}
\addcontentsline{toc}{chapter}{Úvod}

\chapter*{Úvod}
Usporiadaný zoznam (order data structure) \cite{paper1_ordered_list}  je~dátová štruktúra, ktorá~uchováva úplné usporiadanie podliehajúce operáciám: Insert(X,~Y), Delete(X) a Order(X,~Y). Operácia Insert(X, Y) vkladá do~úplného usporiadania nový prvok~Y bezprostredne za~prvok~X. Operácia Delete(X) odstraňuje z~úplného usporiadania prvok~X. Operácia Order(X,~Y) odpovedá, či v~úplnom usporiadaní prvok~X predchádza prvok~Y.
Efektívne algoritmy pre~prácu s~usporiadanými zoznamami majú uplatnenie vo~viacerých oblastiach informatiky, napríklad v~grafových algoritmoch alebo dátových štruktúrach odolných voči chybám.

Cieľom bakalárskej práce je popísať a~porovnať vybrané efektívne riešenia usporiadaného zoznamu, implementovať ich a~vytvoriť vizualizér. Konkrétne sa jedná o~dátové štruktúry a~s~nimi spojené algoritmy z~vedeckých článkov \textit{Two~Simplified Algorithms for~Maintaining Order in~a~List} \cite{paper1_ordered_list} a~\textit{File Maintenance: When~in~Doubt, Change the~Layout!} \cite{paper2_file_maintenance}.
Uvedené články sú veľmi stručné. Práca sa ich riešeniam preto venuje podrobnejšie, so~zámerom pomôcť čitateľovi jednoduchšie pochopiť fungovanie daných dátových štruktúr. Pomôckou pri~zoznamovaní sa s~novými algoritmami má byť tiež spomínaný vizualizér. V~dobe písania práce sa nepodarilo nájsť žiadny obdobný nástroj pre~vizualizáciu daných riešení usporiadaného zoznamu.

Práca sa najskôr zameriava na~popis štruktúr a~náležiacich algoritmov. Text dopĺňajú príklady a~pseudokódy algoritmov. Ďalej sa venuje vzájomnému porovnaniu popísaných riešení. Následne sa presúva k~podrobnostiam ohľadom~vývoja vizualizéru a~taktiež použitia výslednej aplikácie.

Hlavným prínosom práce je vytvorený vizualizér podporujúci operácie Insert, Delete a~Order na~usporiadanom zozname. Užívateľ má na~výber z~dvoch rôznych dátových štruktúr, ktorými~môže byť usporiadaný zoznam implementovaný. Samotná práca tiež slúži ako~študijný materiál pre~zoznámenie sa s~témou usporiadaných \mbox{zoznamov} či~konkrétnych efektívnych riešení.



\chapter{Prehľadová kapitola}
Usporiadaný zoznam (order data structure) \cite{paper1_ordered_list}  je~dátová štruktúra, ktorá~uchováva úplné usporiadanie podliehajúce operáciám: Insert(X,~Y), Delete(X) a Order(X,~Y). Operácia Insert(X, Y) vkladá do~úplného usporiadanie nový prvok~Y bezprostredne za~prvok~X. Operácia Delete(X) odstraňuje z~úplného usporiadania prvok~X. Operácia Order(X,~Y) odpovedá, či v~úplnom usporiadaní prvok~X predchádza prvok~Y.

Cieľom tejto bakalárskej práce je popísať a~porovnať vybrané efektívne spôsoby implementácie usporiadaného zoznamu, konkrétne dátové štruktúry a~s~nimi spojené algoritmy z~vedeckých článkov \textit{Two~Simplified Algorithms for~Maintaining Order in~a~List} \cite{paper1_ordered_list} a~\textit{File Maintenance: When~in~Doubt, Change the~Layout!} \cite{paper2_file_maintenance}. Uvedené články sú veľmi stručné. Táto práca sa ich riešeniam preto venuje podrobnejšie, so~zámerom pomôcť čitateľovi jednoduchšie pochopiť fungovanie daných dátových štruktúr.

Súčasťou bakalárskej práce je implementácia popísanej dátovej štruktúry a~tvorba vizualizačného nástroja, ktorý demonštruje priebeh realizácie operácií Insert, Delete a~Order.

Jedno z~najefektívnejších riešení usporiadaného zoznamu pochádza už~z~roku~1988. Profesori Daniel D. Sleator a~Paul F. Dietz v článku \textit{Two~Algorithms for~Maintaining Order in~a~List} \cite{paper3_1988} popisujú dva rôzne algoritmy. Prvý algoritmus umožňuje vykonávať operácie Insert, Delete a~Order s~konštantnou asymptotickou amortizovanou časovou zložitosťou O(n). Druhý algoritmus umožňuje vykonávať všetky operácie s~konštantnou asymptotickou časovou zložitosťou O(n) v najhoršom prípade. Táto práca sa zameriava na~novšie riešenia, na~základe zhodnotenia odborníkov z~oblasti:
\uv{Známe optimálne riešenia od~Dietza a~Sealtora sú komplikované. Prezentujeme nové algoritmy, ktoré zodpovedajú medziam\footnote{Medze v tomto kontexte znamenajú časovú náročnosť operácií.} od~Dietza a~Sealtora. Naše riešenia sú jednoduché a~prezentujeme experimentálny dôkaz, ktorý napovedá, že~v~praxi fungujú lepšie.} \cite{paper1_ordered_list}

Návrh implementácie vychádza z~existujúceho vizualizéru\footnote{Dostupné na \url{ https://justforfuncoding.github.io/BITvisualization/}.} operácií  range update a~range query na~binárne indexovanom strome, ktorý tiež vznikol ako~súčasť bakalárskej práce \cite{Kridl2022thesis}. Vizualizér sa spúšťa vo~webovom prehliadači. Na~výstavbu stránky je použitý jazyk HTML5 v~kombinácii s~jazykom JavaScript. Pre~docielenie príjemnejšieho vzhľadu~a správneho zvýraznenia jednotlivých častí je použité rozšírenie CSS. Samotné dátové štruktúry sú naprogramované v~jazyku Python pre~jednoduchú transformáciu pseudokódov na~funkčný Python kód.


\chapter{Usporiadaný zoznam}

\textbf{Lineráne usporiadaná množina} je množina, na ktorej je definované úplné usporiadanie. Usporiadanie je binárna relácia, ktorá je reflexívna, tranzitívna a antisymetrická. Usporiadanie budeme označovať symbolom $<$. Usporiadanie je úplné, ak každé dva prvky množiny sú porovnateľné, tj. x<y alebo y<x.

V rámci ľubovoľnej množiny $M$ hovoríme, že prvok $x$ je \emph{priamy predchodca} prvku $y$, ak platí $x, y \in M, \nexists z \in M: (x < z < y)$, respektíve prvok $x$ je \emph{priamy nasledovník} prvku $y$, ak platí $x, y \in M, \nexists z \in M: (y < z < x)$.\\

\textbf{Usporiadaný zoznam} (order data structure) definujeme ako dátovú štruktúru, ktorá uchováva neprázdnu \textit{lineárne usporiadanú množinu objektov} a môžeme na nej vykonávať operácie:
\begin{compactenum}
    \item \textit{Insert(x, y)}: vkladá do uchovávanej množiny nový objekt $y$ ako priameho nasledovníka existujúceho objektu $x$.
    % Po vykonaní operácie platí:
    % \begin{compactitem}
    %     \item $x < y$
    %     \item $\forall z \in M: (z < x) \implies (z < y) $
    %     \item $\forall z \in M: (x < z) \land (z \neq y) \implies (y < z)$
    % \end{compactitem}

    \item \textit{Delete(x)}: odstraňuje z uchovávanej množiny existujúci objekt $x$.
    \item \textit{Order(x, y)}: odpovedá, či $x$ je predchodca objektu $y$ pre existujúce objekty $x$ a $y$ z uchovávanej množiny.
\end{compactenum}
Predpokladáme, že:
\begin{compactitem}
    \item Štruktúra je inicializovaná operáciou \textit{Initialize(x)} a po inicializácii uchováva množinu obsahujúcu objekt x.
    \item Štruktúra nikdy neostane s prázdnou množinou objektov.\\
\end{compactitem}

Príklad 1:
Máme usporiadaný zoznam s množinou objektov $A < B < C$ a vykonávame na ňom nasledovné operácie v poradí v akom sú uvedené:\\
\begin{table}
\begin{tabularx}{\textwidth}{| l | l | l |}
    % \toprule
    operácia & návratová hodnota & množina objektov po operácii \\
    \midrule
    $Insert(B, D)$ &  & $A < B < D < C$\\
    $Insert(B, E)$ &  & $A < B < E < D < C$\\
    $Order(D, E)$ & $false$ & $A < B < E < D < C$\\
    $Order(E, C)$ & $true$ & $A < B < E < D < C$\\
    $Delete(A)$ &  & $B < E < D < C$\\
    $Insert(B, C)$ & \multicolumn{2}{l|}{\textit{chyba/ nedefinované chovanie (množina už obsahuje C)}}\\
    $Order(A, B)$ & \multicolumn{2}{l|}{\textit{chyba/ nedefinované chovanie (množina neobsahuje A)}}\\
    $Delete(F)$ & \multicolumn{2}{l|}{\textit{chyba/ nedefinované chovanie (množina neobsahuje F)}}\\
    % \bottomrule
  \end{tabularx}
\end{table}

% \chapter{Intuitívna implementácia poľom}
% Jednou z možností implementácie usporiadaného zoznamu je ukladať objekty v poli, pričom poradie prvkov v poli odpovedá ich usporiadaniu od najmenšieho po najväčší.

% Operácia $Insert(x, y)$ vkladá nový objekt $y$ do poľa hneď za $x$. Elementy poľa napravo od $x$ musíme posunúť o jednu pozíciu doprava. Preto má táto operácia časovú zložitosť $O(n)$.

% Operácia $Delete(x)$ odstraňuje objekt $x$ z poľa. 
% Aby sme zaplnili prázdne miesto, musíme všetky objekty v poli napravo od $x$ posunúť o jednu pozíciu doľava. Operácia má preto časovú zložitosť $O(n)$.

% Operácii $Order(x, y)$ stačí porovnať indexy prvkov $x$ a $y$. Objekt uložený v poli na nižšom indexe predchádza prvok uložený na vyššom indexe. Preto platí $Order(x, y) \iff index(x) < index(y)$.


\chapter{Spájaný zoznam}

Jednou z možností implementácie usporiadaného zoznamu je ukladať objekty v obojsmerne spájanom zozname (doubly linked list). Každý uzol spájaného zoznamu je jeden objekt a má odkaz na svojho priameho nasledovníka a priameho predchodcu. Poradie v akom sú objekty uložené v spájanom zozname odpovedá ich usporiadaniu od najmenšieho po najväčší.

V rámci tejto práce viackrát využívame obojsmerný spájaný zoznam. Okrem predpokladaných atribútov $head$ a $tail$ ho rozšírime o metódu $InsertNodeAfter(x, y)$, ktorá vkladá nový uzol $y$ za uzol $x$. Pod aliasom $RemoveNode(x)$ rozumieme štandardnú metódu spájaného zoznamu $Delete(x)$, ktorá odstráni uzol $x$ zo spájaného zoznamu (alias $RemoveNode(x)$ používame pre odlíšenie od operácie $Delete(x)$ na usporiadanom zozname).

Operácia $Insert(x, y)$ vkladá nový objekt $y$ do zoznamu ako nasledovníka $x$. Odpovedá spomínanej metóde spájaného zoznamu $InsertNodeAfter(x, y)$. Stačí nastaviť nové vzťahy priamych nasledovníkov a predchodcov pre uzol $y$ a uzly s ním susediace. Operácia má preto časovú zložitosť $O(1)$.

Operácia $Delete(x)$ odstraňuje $x$ zo zoznamu. Odpovedá metóde spájaného zoznamu $RemoveNode(x)$.  Opäť stačí nastaviť nové vzťahy priamych prechodcov a následníkov pre uzly susediace s $x$. Operácia má preto časovú zložitosť $O(1)$.

Operácia $Order(x, y)$ odpovedá, či $x < y$, teda či sa $x$ nachádza bližšie k začiatku spájaného zoznamu než $y$. Postupne prechádza zoznam, kým nenájde uzol $x$ alebo $y$. Ak ako prvý nájde uzol $x$, platí $x < y$. V opačnom prípade $x > y$. Operácia po jednom prechádza zoznam o $n$ objektoch, preto má časovú zložitosť $O(n)$.

\SetAlgorithmName{Algoritmus}{Zoznam algoritmov} 

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na uzol v zozname),\\
y  (ukazateľ na nový uzol),\\
linkedList (spájaný zoznam)}
\hrule\vspace{0.2em}
$y.next \leftarrow x.next$\;

\If {y.next == null}
{
    $linkedList.tail \leftarrow y$\;
}

\Else
{
    $y.next.prev \leftarrow y$\;
}

$y.prev \leftarrow x$\;

$x.next \leftarrow y$\;

\caption{InsertNodeAfter metóda spájaného zoznamu}
\end{algorithm}

% \begin{algorithm}
% \SetKwInOut{Input}{input}
% \Input{x (ukazateľ na objekt v zozname),\\
% y  (ukazateľ na nový objekt),\\
% linkedList (spájaný zoznam objektov)}
% \hrule\vspace{0.2em}
% $y.next \leftarrow x.next$\;

% \If {y.next == null}
% {
%     $linkedList.tail \leftarrow y$\;
% }

% \Else
% {
%     $y.next.prev \leftarrow y$\;
% }

% $y.prev \leftarrow x$\;

% $x.next \leftarrow y$\;

% \caption{Insert na spájanom zozname}
% \end{algorithm}

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na u v zozname),\\
linkedList (spájaný zoznam)}
\hrule\vspace{0.2em}
\If {x.prev == null}
{
    $linkedList.head \leftarrow x.next$\;
}
\Else
{
    $x.prev.next \leftarrow x.next$\;
}
\If {x.next == null}
{
    $linkedList.tail \leftarrow x.prev$\;
}
\Else
{
    $x.next.prev \leftarrow x.prev$\;
}
\caption{RemoveNode metóda spájaného zoznamu}
\end{algorithm}

% \begin{algorithm}
% \SetKwInOut{Input}{input}
% \Input{x (ukazateľ na objekt v zozname),\\
% linkedList (spájaný zoznam objektov)}
% \hrule\vspace{0.2em}
% \If {x.prev == null}
% {
%     $linkedList.head \leftarrow x.next$\;
% }
% \Else
% {
%     $x.prev.next \leftarrow x.next$\;
% }
% \If {x.next == null}
% {
%     $linkedList.tail \leftarrow x.prev$\;
% }
% \Else
% {
%     $x.next.prev \leftarrow x.prev$\;
% }
% \caption{Delete na spájanom zozname}
% \end{algorithm}

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na objekt v zozname),\\
linkedList (spájaný zoznam objektov)}
\Output{pravdivostná hodnota (x > y)}
\hrule\vspace{0.2em}
node $\leftarrow$ linkedList.head\;
\While{node != null}
{
    \If{node == x}
    {
        \Return{true}\;
    }
    \If{node == y}
    {
        \Return {false}\;
    }
    $node \leftarrow node.next$\;
}
\caption{Order na spájanom zozname}
\end{algorithm}


\chapter{Spájaný zoznam s tagmi}

V tejto kapitole sa budeme venovať riešeniu z článku \textit{Two Simplified Algorithms for Maintaining Order in a List} \cite{paper1_ordered_list}.

Táto implementácia tiež vychádza z obojsmerne spájaného zoznamu, v ktorom poradie objektov v zozname zodpovedá ich usporiadaniu. Každý objekt v zozname má navyše priradený \textit{tag}. Tagy sú celé čísla a platí $x < y \iff x.tag < y.tag$, teda každý objekt má vyšší tag než jeho predchodca. Tagy v rámci zoznamu preto rastú smerom k poslednému objektu. Hodnoty tagov sú obmedzené na interval $[0, u]$. Tagy nám zjednodušujú operáciu Order (stačí porovnať tagy prvkov), no prinášajú nové otázky:
\begin{compactenum}
  \item voľba hornej hranice intervalu tagov $u$
  \item stratégia priraďovania tagov pre nové objekty
  \item riešenie situácie, kedy pre nový objekt nemáme dostupný tag (rozdiel tagov jeho predchodcu a následníka je 1).
\end{compactenum}

\subsection{Analógia s binárnym stromom}
Keď zapisujeme tagy v binárnej sústave, môžeme si štruktúru predtaviť ako prefixový strom, ktorého listami sú objekty, a cesta od koreňa k listu odpovedá tagu dosiahnutého objektu, viď obrázok nižšie:

\includegraphics[width=\textwidth]{graphics/graphviz.png}

Pri implementácii nám stačí uchovávať spájaný zoznam objektov, predstava virtuálneho stromu nám len pomáha pri teoretickom skúmaní štruktúry, nazývame ho preto \textit{virtuálny strom}. Keďze každý bit tagu je buď $0$ alebo $1$, je tento strom binárny a má hĺbku odpovedajúcu dĺžke reťazca binárneho zápisu tagu, t.j. $\log{u}$.

Každý vnútorný uzol tohoto stromu identifikuje \textit{rozhranie tagov}, ktorým je prefixom. Toto rozhranie tagov odpovedá podzoznamu objektov (sublist), ktoré sú listami dosiahnuteľnými z tohoto uzlu. Každý objekt patrí do $\log{u}$ takýchto rozhraní tagov.

\subsection{Rekonštrukcia zoznamu (rebuild)}

Aktuálny počet objektov v zozname označujeme $n$. Počet objektov pri poslednej \textit{rekonštrukcii (rebuild)} zoznamu označujeme $N$. Rekonštrukciu zoznamu realizujeme, keď je porušený \textit{invariant 1:} $N/2 <= n <= 2N$.

Pri rekonštrukcii priraďujeme $N = n$. Na základe nového $N$ priraďujeme $u = N^c$, kde $c$ je konštanta. V rámci tejto práce pracujeme s $c = 2$, takže $u = N^2$. Následne prechádzame zoznam objektov a priraďujeme im nové tagy z intervalu $[0, u]$ s rovnomernými medzerami.

Príklad 2.:
Tabuľka nižšie ukazuje, ako sa menia hodnoty $n, N,$ a $u$ pri vykonaní operácií:
\begin{table}
\begin{tabularx}{\textwidth}{| l | l | l | l | l | l}
    % \toprule
    operácia & usporiadanie & $n$ & $N$ & $u$ & poznámka \\
    \midrule
    $Initialize(X)$ & $X$ & $1$ & $1$ & $2$ & inicializácia\\
    $Insert(X, A)$ & $X < A$ & $2$ & $2$ & $4$ & rekonštrukcia\\
    $Insert(A, B)$ & $X < A < B$ & $3$ & $2$ & $4$ & \\
    $Insert(B, C)$ & $X < A < B < C$ & $4$ & $2$ & $4$ & \\
    $Insert(X, Y)$ & $X < Y < A < B < C$ & $5$ & $5$ & $25$ & rekonštrukcia\\
    $Delete(C)$ & $X < Y < A < B$ & $4$ & $5$ & $25$ & \\
    $Delete(B)$ & $X < Y < A $ & $3$ & $5$ & $25$ & \\
    $Delete(A)$ & $X < Y$ & $2$ & $2$ & $4$ & rekonštrukcia\\
    % \bottomrule
  \end{tabularx}
\end{table}

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{linkedList (spájaný zoznam objektov),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu),\\
u (horná hranica tagov)}
\hrule\vspace{0.2em}
$N \leftarrow n$\;

$u \leftarrow N^2$\;

$tagOffset \leftarrow u / n$; \tcp*[h]{floored division}

$tag \leftarrow 0$\;

\ForEach {node in linkedList}
{
    $node.tag \leftarrow tag$\;
    
    $tag \leftarrow tag + tagOffset$\;
}

\caption{Rebuild/rekonštrukcia spájaného zoznamu s tagmi}
\end{algorithm}

\section{Insert(x, y)}

Keď vkladáme do zoznamu nový objekt $y$ medzi objekty $x$ a $z$, musíme mu priradiť tag splňajúci $x.tag < y.tag < z.tag$ (respektíve $x.tag < y.tag <= u$, ak $x$ nemá následníka).
Pokiaľ nie je dostupný žiadny tag z daného rozpätia (rozdiel medzi tagmi $x$ a $z$ je 1, respektíve $x.tag = u$), musíme pretagovať časť zoznamu (relabeling).

Ak je po vložení nového objektu porušený invariant $N/2 <= n <= 2N$, realizujeme rekonštrukciu zoznamu.

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na nový objekt),\\
linkedList (spájaný zoznam objektov s tagmi),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu),\\
u (horná hranica tagov)}
\hrule\vspace{0.2em}
$z \leftarrow x.next$\;

\If{(z == null and x.tag == u) or (x.tag + 1 == z.tag)}
{
    $Relabel(x)$\;
}

$y.tag \leftarrow ChooseNewTagAfter(x)$\;

% $y.next \leftarrow x.next$\;
% \If {y.next == null}
% {
%     $linkedList.tail \leftarrow y$\;
% }
% \Else
% {
%     $y.next.prev \leftarrow y$\;
% }
% $y.prev \leftarrow x$\;
% $x.next \leftarrow y$\;

$linkedList.InsertNodeAfter(x, y)$\;


$n \leftarrow n + 1$\;

\If{!( N/2 <= n <= 2N)}
{
    $Rebuild()$\;
}
\caption{Insert na spájanom zozname s tagmi}
\end{algorithm}

\subsection*{Stratégia voľby tagov}

\textit{Two Simplified Algorithms for Maintaining Order in a List} \cite{paper1_ordered_list} experimentálne porovnáva 2 stratégie výberu nového tagu:
\begin{compactenum}
  \item Po sebe idúce tagy (consecutive inserts): tag nového objektu je o 1 vyšší než tag jeho predchodcu.
  \item Priemerované tagy (average inserts): tag nového objektu je priemer jeho susedov.
\end{compactenum}
Pri stratégii po sebe idúcich tagov musíme pretagovať menší interval každý druhý insert. Pri stratégii priemerovaných tagov musíme pretagovať väčšie intervaly, no menej často. Používanie priemerovaných tagov sa ukázalo o konštantu rýchlejšie než po sebe idúce tagy.
% Dôkaz časovej náročnosti algoritmu pre insert však nie je závislý na stratégii voľby tagov.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname, za ktorým cheme vybrať tag)}
\Output{tag pre nový objekt vkladaný za x}
\hrule\vspace{0.2em}
$minTag \leftarrow x.tag + 1$\;

$maxTag \leftarrow u$\;

\If {x.next != null}
{
    $maxTag \leftarrow x.next.tag - 1$\;
}

\Return {(minTag + maxTag) / 2}; \tcp{floored division}
\caption{ChooseNewTag / voľba tagu pre nový objekt  }
\end{algorithm}

\subsection{Pretagovanie (relabeling)}
Pretagovanie pri vkladaní objektu $y$ za $x$ pozostáva z 2 častí:
\begin{compactenum}
    \item Nájdenie najmenšieho rozhrania tagov, do ktorého patrí $x$ a \textit{nepreteká}.
    \item Priradenie nových tagov objektom v nájdenom rozhraní.
\end{compactenum}
Pri hľadaní najmenšieho rozhrania, ktoré nepreteká, postupujeme vo virtuálnom strome od listu objektu $x$ smerom ku koreňu. Skúmané rozhrania tagov teda rastú geometricky, ich veľkosť odpovedá $2^i$, kde $i$ je vzdialenosť od listov vo virtuálnom strome (interval level). Zastavíme sa na prvom rozhraní, ktoré \textit{nepreteká}.
Hovoríme, že rozhranie tagov \textit{preteká (overflow)}, ak je jeho \textit{hustota zaplnenia (density)} vyššia ako \textit{hranica pretečenia (overflow threshold)}. \textit{Hustota zaplenia} rozhrania tagov je podiel využitých tagov z tohoto rozhrania. Hustotu zaplnenia počítame prechádzaním objektov v tomto rozhraní. Hranicu pretečenia počítame nasledovne:
\begin{compactenum}
    \item Pre rozhranie tagov s veľkosťou $2^0 = 1$ (listy vo virtuálnom strome) je hranica pretečenia $T_0 = 1$.
    \item Inak, pre rozhrania veľkosti $2^i$, $T_i = T_{i-1} / T = T^{-i}$, kde $T$ je hodnota medzi 1 a 2. Pri každom pretagovaní vypočítame novú najnižšiu možnú hodnotu $T$, pri ktorej koreň nepreteká.
\end{compactenum}
Vďaka invariantu $N/2 <= n <= 2N$ koreň virtuálneho stromu nikdy nepretečie, takže vždy môžeme v najhoršom prípade pretagovať celý zoznam.
Po nájdení rozhrania, ktoré chceme pretagovať, priraďujeme objektom z tohoto rozhrania nové tagy, ktoré sú rovnomerne rozdistribuované v rámci daného rozhrania.
% Nový objekt $y$ môžeme pridať do zoznamu už pri priraďovaní nových tagov.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname, nad ktorým cheme pretagovať),\\}
\hrule\vspace{0.2em}
\tcp{Find smallest tag interval not in overflow.}
$T \leftarrow CalculateT()$\;
$interval \leftarrow new Interval(x, x)$; \tcp*[h]{Interval containing only x, i.e. [x.tag, x.tag]}

$interval \leftarrow IncreaseInterval(interval)$\;
\tcp{Now interval.level is 1 and interval.size = $2^1$.}
\tcp{interval.fill is calculated in IncreaseInterval by traversing and counting objects in the tag range.}
\tcp{interval.density is calculated as interval.fill / interval.size.}

$intervalOverflowThreshold \leftarrow T\textasciicircum(- interval.level)$

\While{interval.density > intervalOverflowThreshold}
{
    \tcp{Increase interval size.}
    
    $interval \leftarrow IncreaseInterval(interval)$\;
    $intervalOverflowThreshold \leftarrow T\textasciicircum(- interval.level)$\;
}

$AssignNewTags(interval.startNode, interval.fill,$\\
    \hspace{90pt}$interval.minTag, interval.maxTag)$\;
% \tcp{Assign new tags.}

% $tagOffset \leftarrow interval.size / interval.fill$; \tcp*[h]{floored division}

% $tag \leftarrow interval.min$\;

% $sublist \leftarrow SublistForTagInterval(interval)$\;

% \ForEach {node in sublist}
% {
%     $node.tag \leftarrow tag$\;
    
%     $tag \leftarrow tag + tagOffset$\;
% }
\caption{Relabel/pretagovanie na spájanom zozname s tagmi}
\end{algorithm}


\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{startNode (prvý uzol na pretagovanie),\\
$count$ (počet objektov na pretagovanie),\\
$minTag$ (začiatok intervalu priraďovaných tagov),\\
$maxTag$ (koniec intervalu priraďovaných tagov)}
\hrule\vspace{0.2em}

$tagOffset \leftarrow (maxTag - minTag) / n$; \tcp*[h]{floored division}

$tag \leftarrow minTag$\;

$nodee \leftarrow startNode$

\While {$count > 0$}
{
    $node.tag \leftarrow tag$\;
    $node \leftarrow node.next$\;
    $count \leftarrow count - 1$\;
    $tag \leftarrow tag + tagOffset$\;
}
\caption{AssignNewTags}
\end{algorithm}


\section{Delete(x)}
Pri odstraňovaní objektu stačí nastaviť nové vzťahy priameho predchodcu/následníka pre uzly susediace s $x$, prípadne aktualizovať head a tail spájaného zoznamu.

Ak je po odstránení porušený invariant $N/2 <= n <= 2N$, realizujeme rekonštrukciu zoznamu.

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
linkedList (spájaný zoznam objektov),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu)}
\hrule\vspace{0.2em}
% \If {x.prev == null}
% {
%     $linkedList.head \leftarrow x.next$\;
% }
% \Else
% {
%     $x.prev.next \leftarrow x.next$\;
% }
% \If {x.next == null}
% {
%     $linkedList.tail \leftarrow x.prev$\;
% }
% \Else
% {
%     $x.next.prev \leftarrow x.prev$\;
% }

$linkedList.RemoveNode(x)$

$n \leftarrow n - 1$\;

\If{!( N/2 <= n <= 2N)}
{
    $Rebuild()$\;
}
\caption{Delete na spájanom zozname s tagmi}
\end{algorithm}

\section{Order(x, y)}
Platí $x.tag < y.tag \iff x < y$. 
K rozhodnutiu, či $x$ je predchodcom $y$, nám preto stačí porovnať  $x.tag$ a $y.tag$.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na objekt v zozname)}
\Output{pravdivostná hodnota (x < y)}
\hrule\vspace{0.2em}
\Return {x.tag < y.tag}\;
\caption{Order na spájanom zozname s tagmi}
\end{algorithm}

\chapter{Dvojposchodový spájaný zoznam s tagmi}
Článok \textit{Two Simplified Algorithms for Maintaining Order in a List} \cite{paper1_ordered_list} ďalej uvádza spôsob, akým vieme pretagovanie a rekonštrukciu spájaného zoznamu s tagmi zefektívniť. Dátovú štruktúru rozdelíme na viacero poschodí, čím získame amortizovanú časovú zložitosť $\O(1)$ pre Insert a Delete a zachováme $\O(1)$ v najhoršom prípade pre Order.

Spájaný zoznam s $N$ objektami rozsekáme na $N/log(N)$ menších podzoznamov o $log(N)$ objektoch, ktoré tvoria nižšie poschodie. Vyššie poschodie tvorí spájaný zoznam reprezentantov týchto podzoznamov. Každý reprezentant má odkaz na podzoznam, ktorý reprezentuje. Každý vložený objekt má odkaz na reprezentanta podzoznamu, v ktorom sa nachádza. Reprezentanti podzoznamov majú tiež tagy a ich poradie odpovedá originálnemu poradiu podzoznamov. Pre reprezentantov podzoznamov $a$ a $b$ platí $a.tag < b.tag$ práve vtedy, ak objekty v podzozname $a$ predchádzajú objekty podzoznamu $b$ (hovoríme, že podzoznam $a$ predchádza podzoznam $b$). Tagy reprezentantov preto rastú smerom k poslednému podzoznamu. Tagy v rámci jedného podzoznamu sú nezávislé od tagov ostatných podzoznamov aj zoznamu reprezentantov. V rámci každého podzoznamu fungujú tagy ako doteraz, teda $x < y \iff x.tag < y.tag$. 

\subsection{Rekonštrukcia dvojposchodového zoznamu}

Aktuálny počet objektov v usporiadanom zozname označujeme $n$. Počet objektov pri poslednej rekonštrukcii označujeme $N$. Rekonštrukciu zoznamu realizujeme, keď je porušený \textit{invariant 1:} $N/2 <= n <= 2N$.
Pri rekonštrukcii priraďujeme $N = n$ a objekty usporiadaného zoznamu nanovo rozsekáme do $N/log(N)$ podzoznamov o $log(N)$ objektoch. Pre podzoznamy určujeme novú hornú hranicu intervalu tagov $u_s = N_s^c$, kde $N_s$ odpovedá dĺžke podzoznamu $N_s = log(N)$ a $c = 2$ (zvolené pre potreby tejto práce v predošlej kapitole). Zoznam reprezentantov má inú dĺžku než podzoznamy, má vlastné $u_r = N_r^c$, kde $N_r$ odpovedá dĺžke zoznamu reprezentantov $N_r = N/log(N)$. Následne priradíme nové tagy objektom v jednotlivých podzoznamoch aj reprezentantom podzoznamov.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{representatives (spájaný zoznam reprezentantov podzoznamov),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu)
% $u_s$ (horná hranica tagov pre podzoznamy),\\
% $u_r$ (horná hranica tagov pre reprezentantov podzoznamov)
}
\hrule\vspace{0.2em}
$N \leftarrow n$\;

$N_s \leftarrow log(N)$; \tcp*[h]{new count of elements in sublists}

$N_r \leftarrow N/log(N)$; \tcp*[h]{new count of sublist representatives}

$u_s \leftarrow N_s^2$\;

$u_r \leftarrow N_r^2$\;

$newRepresentatives \leftarrow new~LinkedList()$\;

\For{$i\leftarrow 0$ \KwTo $N_r$}
{
    $sublist \leftarrow TakeFromSublists(N_s, representatives)$\;
    
    \tcp{Take $N_s$ objects from the start of the sorted list -- remove them from original sublist and return them as a linked list.}

    $AssignNewTags(sublist.head, N_s, 0, u_s)$\;
    
    $representative \leftarrow new~SublistRepresentative(sublist)$\;

    \ForEach{$node~in~sublist$}
    {
        $node.rep \leftarrow representative$\;
    }
    
    $newRepresentatives.Append(representative)$\;
}

$AssignNewTags(newRepresentatives.head, N_r, 0, u_r)$\;

$representatives \leftarrow newRepresentatives$\;

\caption{Rebuild/rekonštrukcia dvojposchodového spájaného zoznamu s tagmi}
\end{algorithm}


\section{Insert(x,y)}

Zavádzame \textit{invariant 2:} pre každý podzoznam $s$ v usporiadanom zozname platí: $0 < n_s <= 2N_s $, kde $n_s$ je aktuálny počet objektov v danom podzozname. Ak pred vložením prvku do podzoznamu platí $ n_s = 2N_s = 2log(N)$ (hranica by bola presiahnutá) vykonávame najprv nasledovné operácie:
\begin{compactenum}
    \item{Podzoznam rozsekneme na 2 polovice o $N_s = log(N)$ objektoch.}
    \item{Vytvoríme reprezentanta pre nový podzoznam vzniknutý z druhej polovice objektov (druhou polovicou rozumieme polovicu, ktorej objekty sú v usporiadaní následníkmi prvej polovice). Vložíme ho do zoznamu reprezentantov ako priameho následníka reprezentanta pôvodneho podzoznamu (prvej polovice). To zahŕňa priraďenie tagu novému reprezentantovi tak, aby splňal $r_1.tag < r_2.tag < r_3.tag$ (respektíve $r_1.tag < r_2.tag <= u_r$, ak $r_1$ nemá pred vložením následníka), kde $r_1$ je reprezentant prvej polovice,  $r_2$ je reprezentant druhej polovice, $r_3$ je priamy následník $r_1$ (pred vložením $r_2$). Ak takýto tag nie je dostupný, pretagujeme zoznam reprezentantov.
    \item{Na všetkých objektoch nového podzoznamu (t.j. druhá polovica) aktualizujeme odkaz na reprezentanta podzoznamu.}
    \item{Vložíme nový objekt $y$ za objekt $x$.}
    
\end{compactenum}

Objekt $y$ vkladáme do podzoznamu obsahujúceho objekt $x$ ako priameho následníka objektu $x$ a priraďujeme mu tag spĺňajúci $x.tag < y.tag < z.tag$ (respektíve $x.tag < y.tag <= u$, ak $x$ nemá následníka), kde . Ak takýto tag nie je dostupný, pretagujeme časť podzoznamu, maximálne však celý tento podzoznam.

Ak je po vložení nového objektu porušený invariant $N/2 <= n <= 2N$, realizujeme rekonštrukciu zoznamu.

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na nový objekt),\\
representatives (spájaný zoznam reprezentantov podzoznamov),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu),\\
u (horná hranica tagov)}
\hrule\vspace{0.2em}
$N_s \leftarrow log(N)$\;
$sublist \leftarrow x.rep.sublist$\;
\If{$sublist.n_s == 2N_s$}
{
    $SplitInHalf(sublist)$\;
    $sublist \leftarrow x.rep.sublist$; \tcp*[h]{Might be in new sublist.}
    
}

$z \leftarrow x.next$\;

\If{($z == null~and~x.tag == u$) or ($x.tag + 1 == z.tag$)}
{
    $Relabel(x)$\;
}

$y.tag \leftarrow ChooseNewTagAfter(x)$\;

% $y.next \leftarrow x.next$\;
% \If {y.next == null}
% {
%     $linkedList.tail \leftarrow y$\;
% }
% \Else
% {
%     $y.next.prev \leftarrow y$\;
% }
% $y.prev \leftarrow x$\;
% $x.next \leftarrow y$\;
$sublist.InsertNodeAfter(x, y)$\;
$sublist.n_s \leftarrow sublist.n_s + 1$\;


$n \leftarrow n + 1$\;

\If{!( $N/2 <= n <= 2N$)}
{
    $Rebuild()$\;
}
\caption{Insert na dvojposchodovom spájanom zozname s tagmi}
\end{algorithm}

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{sublist (spájaný podzoznam objektov),\\
representatives (spájaný zoznam reprezentantov podzoznamov),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu)}
\hrule\vspace{0.2em}
\tcp{Set \textit{node} to the first node of the second half.}
$N_s \leftarrow log(N)$\;
$node \leftarrow sublist.head$\;
\For{$i \leftarrow 0$ \KwTo $N_s$}
{
    $node \leftarrow node.next$\;
}

\vspace{10pt}

\tcp{Split into two sublists.}
$secondSublist \leftarrow new~LinkedList()$\;
$secondSublist.head \leftarrow node$\;
$secondSublist.tail \leftarrow sublist.tail$\;
$secondSublist.n_s \leftarrow N_s$\;
$sublist.n_s \leftarrow N_s$\;
$sublist.tail \leftarrow node.prev$\;
$node.prev.next \leftarrow null$\;
$node.prev \leftarrow null$

\vspace{10pt}

\tcp{Create a new sublist representative.}
$secondRep \leftarrow new~SublistRepresentative(secondSublist)$\;

$nextRep \leftarrow x.rep.next$\;
$u_r = (N/log(N))^2$\;
\If{($nextRep == null and x.rep.tag == u_r$) or ($x.rep.tag + 1 == nextRep.tag$)}
{
    $Relabel(x.rep)$\;
}
$secondRep.tag \leftarrow ChooseNewTagAfter(x.rep)$\;
$representatives.InsertNodeAfter(x.rep, secondRep)$\;

\vspace{10pt}

\tcp{Set new representative for nodes in the new sublist.}
$node \leftarrow secondSublist.head$\;
\While{$node \neq null$}
{
    $node.rep \leftarrow secondRep$\;
    $node \leftarrow node.next$\;
}

\caption{SplitInHalf na dvojposchodovom spájanom zozname s tagmi}
\end{algorithm}


\section{Delete(x)}

Pri odstraňovaní objektu stačí nastaviť nové vzťahy priameho predchodcu/následníka pre uzly susediace s $x$.

Ak ostane po odstránení podzoznam prázdny (porušený invariant $0 < n_s <= 2N_s $), odstránime ho zo zoznamu reprezentantov.

Ak je porušený invariant $N/2 <= n <= 2N$, realizujeme rekonštrukciu zoznamu.

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
representatives (spájaný zoznam reprezentantov podzoznamov),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu)}
\hrule\vspace{0.2em}
$N_s = log(N)$\;
$sublist = x.rep.sublist$\;
% \If {x.prev == null}
% {
%     $sublist.head \leftarrow x.next$\;
% }
% \Else
% {
%     $x.prev.next \leftarrow x.next$\;
% }
% \If {x.next == null}
% {
%     $sublist.tail \leftarrow x.prev$\;
% }
% \Else
% {
%     $x.next.prev \leftarrow x.prev$\;
% }
$sublist.RemoveNode(x)$\;
% \tcp{Remove updates next/prev properties in neighbours and head/tail properties in the linked list.}

$n \leftarrow n - 1$\;
$sublist.n_s \leftarrow sublist.n_s - 1$\;

\If{!($0 < sublist.n_s$)}
{
    $representatives.RemoveNode(x.rep)$\;
    % \tcp{Remove updates next/prev properties in neighbours and head/tail properties in the linked list.}
}

\If{!( $N/2 <= n$)}
{
    $Rebuild()$\;
}
\caption{Delete na viacposchodovom spájanom zozname s tagmi}
\end{algorithm}


\section{Order(x, y)}

Tagy v rámci každého podzoznamu sú nezávislé od ostatných podzoznamov, preto $x.tag < y.tag \iff x < y$ platí len vtedy, ak sa objekty $x$ a $y$ nachádzajú v rovnakom podzozname.
Pri rozhodovaní, či $x < y$, najprv porovnávame tagy reprezentantov ich podzoznamov:
\begin{compactitem}
    \item{Ak $x.rep.tag = y.rep.tag$, tak sa objekty $x$ a $y$ nachádzajú v rovnakom podzozname, teda platí $x.tag < y.tag \iff x < y$.}
    \item{Ak $x.rep.tag < y.rep.tag$, tak všetky objekty v podzozname s $x$ predchádzajú všetky objekty v podzozname s $y$, preto $x < y$.}
    \item{Ak $x.rep.tag > y.rep.tag$, tak všetky objekty v podzozname s $x$ nasledujú v usporiadaní všetky objekty v podzozname s $y$, preto $x \nless y$.}
\end{compactitem}

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na objekt v zozname)}
\Output{pravdivostná hodnota ($x < y$)}
\hrule\vspace{0.2em}
\If{$x.rep.tag == y.rep.tag$}
{
    \Return {$x.tag < y.tag$}\;
}
\Return {$x.rep.tag < y.rep.tag$}\;
\caption{Order na dvojposchodovom spájanom zozname s tagmi}
\end{algorithm}

\clearpage

\chapter{Pole s rezervou}

Kapitola predstavuje alternatívnu implementáciu usporiadaného zoznamu z článku \textit{File Maintenance: When in Doubt, Change the Layout!} \cite{paper2_file_maintenance}.

Objekty ukladáme do fiktívneho úplného binárneho stromu, ktorý je mapovaný do jednorozmerného poľa. Každý list stromu je reprezentovaný rovnako veľkou súvislou disjunktnou\footnote{Časti poľa odpovedajúce jednotlivým listom sa navzájom neprekrývajú.} častou poľa. Každý podstrom odpovedá súvislej časti poľa, ktorá obsahuje reprezentáciu všetkých jeho listov. Koreň teda odpovedá celému poľu.

Každý vnútorný uzol stromu má navyše \textit{rezervu (buffer)}. Čím bližšie k listom je uzol, tým väčšiu rezervu má. Týmto sa z úplného binárneho stromu stáva neuplný ternárny. Vďaka rezerve máme vždy miesto pre vloženie nového prvku, po ktorom nasleduje \textit{vyprázdňovanie} rezerv \textit{(cleanup)}. Efektívnosť poľa s rezervou teda záleží práve na spôsobe vyprázdňovania rezerv.






\clearpage

\chapter{These are}
\section{the available}
\subsection{sectioning}
\subsubsection{commands.}
\paragraph{Paragraphs and}
\subparagraph{subparagraphs are available as well.}
Inside the text, you can also use unnumbered lists,
\begin{itemize}
  \item such as
  \item this one
  \begin{itemize}
    \item     and they can be nested as well.
    \item[>>] You can even turn the bullets into something fancier,
    \item[\S] if you so desire.
  \end{itemize}
\end{itemize}
Numbered lists are
\begin{enumerate}
  \item very
  \begin{enumerate}
    \item similar
  \end{enumerate}
\end{enumerate}
and so are description lists:
\begin{description}
  \item[Description list]
    A list of terms with a description of each term
\end{description}
The spacing of these lists is geared towards paragraphs of text.
For lists of words and phrases, the \textsf{paralist} package
offers commands
\begin{compactitem}
  \item that
  \begin{compactitem}
    \item are
    \begin{compactitem}
      \item better
      \begin{compactitem}
        \item suited
      \end{compactitem}
    \end{compactitem}
  \end{compactitem}
\end{compactitem}
\begin{compactenum}
  \item to
  \begin{compactenum}
    \item this
    \begin{compactenum}
      \item kind of
      \begin{compactenum}
        \item content.
      \end{compactenum}
    \end{compactenum}
  \end{compactenum}
\end{compactenum}
The \textsf{amsthm} package provides the commands necessary for the
typesetting of mathematical definitions, theorems, lemmas and
proofs.

%% We will define several mathematical sectioning commands.
\newtheorem{theorem}{Theorem}[section] %% The numbering of theorems
                               %% will be reset after each section.
\newtheorem{lemma}[theorem]{Lemma}         %% The numbering of lemmas
\newtheorem{corollary}[theorem]{Corollary} %% and corollaries will
                               %% share the counter with theorems.
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\begin{theorem}
  This is a theorem that offers a profound insight into the
  mathematical sectioning commands.
\end{theorem}
\begin{theorem}[Another theorem]
  This is another theorem. Unlike the first one, this theorem has
  been endowed with a name.
\end{theorem}
\begin{lemma}
  Let us suppose that $x^2+y^2=z^2$. Then
  \begin{equation}
    \biggl\langle u\biggm|\sum_{i=1}^nF(e_i,v)e_i\biggr\rangle
    =F\biggl(\sum_{i=1}^n\langle e_i|u\rangle e_i,v\biggr).
  \end{equation}
\end{lemma}
\begin{proof}
  $\nabla^2 f(x,y)=\frac{\partial^2f}{\partial x^2}+
   \frac{\partial^2f}{\partial y^2}$.
\end{proof}
\begin{corollary}
  This is a corollary.
\end{corollary}
\begin{remark}
  This is a remark.
\end{remark}

\chapter{Floats and references}
\begin{figure}
  \begin{center}
    %% PNG and JPG images can be inserted into the document as well,
    %% but their resolution needs to be adequate. The minimum is
    %% about 100 pixels per 1 centimeter or 300 pixels per 1 inch.
    %% That means that a JPG or PNG image typeset at 4 × 4 cm should
    %% be 400 × 400 px large at the bare minimum.
    %%
    %% The optimum is about 250 pixels per 1 centimeter or 600
    %% pixels per 1 inch. That means that a JPG or PNG image typeset
    %% at 4 × 4 cm should be 1000 × 1000 px large or larger.
    \includegraphics[width=6.3cm]{fithesis/logo/mu/fithesis-base-english-color}
  \end{center}
  \caption{The logo of \acrlong{MU} at 6.3\,cm}
  \label{fig:mulogo1}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{minipage}{.5\textwidth}
      \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base-english-color}
    \end{minipage}
    \hfill  % Fill the horizontal space between the images
    \begin{minipage}{.33\textwidth}
      \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base-english-color} \\[1em]
      \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base-english-color}
    \end{minipage}
  \end{center}
\caption{The logo of \acrlong{MU} at $\frac12$ and
    $\frac13$ of text width}
  \label{fig:mulogo2}
\end{figure}

\begin{table}
  \begin{tabularx}{\textwidth}{lllX}
    \toprule
    Day & Min Temp & Max Temp & Summary \\
    \midrule
    Monday & $13^{\circ}\mathrm{C}$ & $21^\circ\mathrm{C}$ & A
    clear day with low wind and no adverse current advisories. \\
    Tuesday & $11^{\circ}\mathrm{C}$ & $17^\circ\mathrm{C}$ & A
    trough of low pressure will come from the northwest. \\
    Wednesday & $10^{\circ}\mathrm{C}$ &
    $21^\circ\mathrm{C}$ & Rain will spread to all parts during the
    morning. \\
    \bottomrule
  \end{tabularx}
  \caption{A weather forecast}
  \label{tab:weather}
\end{table}

The logo of \gls{MU} is shown in Figure \ref{fig:mulogo1} and
Figure \ref{fig:mulogo2} at pages \pageref{fig:mulogo1} and
\pageref{fig:mulogo2}. The weather forecast is shown in Table
\ref{tab:weather} at page \pageref{tab:weather}. The following
chapter is Chapter \ref{chap:matheq} and starts at page
\pageref{chap:matheq}.  Items \ref{item:star1}, \ref{item:star2},
and \ref{item:star3} are starred in the following list:
\begin{compactenum}
  \item some text
  \item some other text
  \item $\star$ \label{item:star1}
  \begin{compactenum}
    \item some text
    \item $\star$ \label{item:star2}
    \item some other text
    \begin{compactenum}
      \item some text
      \item some other text
      \item yet another piece of text
      \item $\star$ \label{item:star3}
    \end{compactenum}
    \item yet another piece of text
  \end{compactenum}
  \item yet another piece of text
\end{compactenum}
If your reference points to a place that has not yet been typeset,
the \verb"\ref" command will expand to \textbf{??} during the first
run of
\texttt{pdflatex \jobname.tex}
and a second run is going to be needed for the references to
resolve. With online services -- such as \Gls{Overleaf} -- this is
performed automatically.

\chapter{Mathematical equations}
\label{chap:matheq}
\TeX{} comes pre-packed with the ability to typeset inline
equations, such as $\mathrm{e}^{ix}=\cos x+i\sin x$, and display
equations, such as \[
  \mathbf{A}^{-1} = \begin{bmatrix}
  a & b \\ c & d \\
  \end{bmatrix}^{-1} =
  \frac{1}{\det(\mathbf{A})} \begin{bmatrix}
  \,\,\,d & \!\!-b \\ -c & \,a \\
  \end{bmatrix} =
  \frac{1}{ad - bc} \begin{bmatrix}
  \,\,\,d & \!\!-b \\ -c & \,a \\
  \end{bmatrix}.
\] \LaTeX{} defines the automatically numbered \texttt{equation}
environment:
\begin{equation}
  \gamma Px = PAx = PAP^{-1}Px.
\end{equation}
The package \textsf{amsmath} provides several additional
environments that can be used to typeset complex equations:
\begin{enumerate}
  \item An equation can be spread over multiple lines using the
    \texttt{multline} environment:
    \begin{multline}
      a + b + c + d + e + f + b + c + d + e + f + b + c + d + e +
f \\
      + f + g + h + i + j + k + l + m + n + o + p + q
    \end{multline}

  \item Several aligned equations can be typeset using the
    \texttt{align} environment:
    \begin{align}
              a + b &= c + d     \\
                  u &= v + w + x \\[1ex]
      i + j + k + l &= m
    \end{align}

  \item The \texttt{alignat} environment is similar to
    \texttt{align}, but it doesn't insert horizontal spaces between
    the individual columns:
    \begin{alignat}{2}
      a + b + c &+ d       &   &= 0 \\
              e &+ f + g   &   &= 5
    \end{alignat}

  \item Much like chapter, sections, tables, figures, or list
    items, equations -- such as \eqref{eq:first} and
    \eqref{eq:mine} -- can also be labeled and referenced:
    \begin{alignat}{4}
      b_{11}x_1 &+ b_{12}x_2  &  &+ b_{13}x_3  &  &             &
        &= y_1,                   \label{eq:first} \\
      b_{21}x_1 &+ b_{22}x_2  &  &             &  &+ b_{24}x_4  &
        &= y_2. \tag{My equation} \label{eq:mine}
    \end{alignat}

  \item The \texttt{gather} environment makes it possible to
    typeset several equations without any alignment:
    \begin{gather}
      \psi = \psi\psi, \\
      \eta = \eta\eta\eta\eta\eta\eta, \\
      \theta = \theta.
    \end{gather}

  \item Several cases can be typeset using the \texttt{cases}
    environment:
    \begin{equation}
      |y| = \begin{cases}
        \phantom-y & \text{if }z\geq0, \\
                -y & \text{otherwise}.
      \end{cases}
    \end{equation}
\end{enumerate}
For the complete list of environments and commands, consult the
\textsf{amsmath} package manual\footnote{
  See \url{http://mirrors.ctan.org/macros/latex/required/amsmath/amsldoc.pdf}.
  The \texttt{\textbackslash url} command is provided by the
  package \textsf{url}.
}.

\chapter{\textnormal{We \textsf{have} \texttt{several} \textsc{fonts}
  \textit{at} \textbf{disposal}}}
The serified roman font is used for the main body of the text.
\textit{Italics are typically used to denote emphasis or
quotations.} \texttt{The teletype font is typically used for source
code listings.} The \textbf{bold}, \textsc{small-caps} and
\textsf{sans-serif} variants of the base roman font can be used to
denote specific types of information.

\tiny We \scriptsize can \footnotesize also \small change \normalsize
the \large font \Large size, \LARGE although \huge it \Huge
is \huge usually \LARGE not \Large necessary.\normalsize

A wide variety of mathematical fonts is also available, such as: \[
  \mathrm{ABC}, \mathcal{ABC}, \mathbf{ABC}, \mathsf{ABC},
  \mathit{ABC}, \mathtt{ABC}
\] By loading the \textsf{amsfonts} packages, several additional
fonts will become available: \[
  \mathfrak{ABC}, \mathbb{ABC}
\] Many other mathematical fonts are available\footnote{
  See \url{http://tex.stackexchange.com/a/58124/70941}.
}.

\chapter{Inserting the bibliography}

After linking a bibliography data\-base files to the document using
the \verb"\"\texttt{thesis\discretionary{-}{}{}setup\{bib\discretionary{=}{=}{=}%
\{\textit{file1},\textit{file2},\,\ldots\,\}\}} command, you can
start citing the entries. This is just dummy text
\parencite{paper1_ordered_list} lightly sprinkled with citations
\parencite[p.~123]{paper1_ordered_list}. Several sources can be cited at
once: \cite{paper1_ordered_list,paper2_file_maintenance,paper2_file_maintenance}.
\citetitle{paper1_ordered_list} was written by \citeauthor{paper1_ordered_list} in
\citeyear{paper1_ordered_list}. We can also produce \textcite{paper1_ordered_list}%
\ or %% Let us define a compound command:
\def\citeauthoryear#1{(\textcite{#1},~\citeyear{#1})}%
\citeauthoryear{paper2_file_maintenance}%
. The full bibliographic citation is:
\emph{\fullcite{paper1_ordered_list}}. We can easily insert a bibliographic
citation into the footnote\footfullcite{paper1_ordered_list}.

The \verb"\nocite" command will not generate any
output\nocite{paper1_ordered_list}, but it will insert its arguments into
the bibliography. The \verb"\nocite{*}" command will insert all the
records in the bibliography database file into the bibliography.
Try uncommenting the command
%%\nocite{*}
and watch the bibliography section come apart at the seams.

When typesetting the document for the first time, citing a
\texttt{work} will expand to [\textbf{work}] and the
\verb"\printbibliography" command will produce no output. It is now
necessary to generate the bibliography by running \texttt{biber
\jobname.bcf} from the command line and then by typesetting the
document again twice. During the first run, the bibliography
section and the citations will be typeset, and in the second run,
the bibliography section will appear in the table of contents.

The \texttt{biber} command needs to be executed from within the
directory, where the \LaTeX\ source file is located. In Windows,
the command line can be opened in a directory by holding down the
\textsf{Shift} key and by clicking the right mouse button while
hovering the cursor over a directory.  Select the \textsf{Open
Command Window Here} option in the context menu that opens shortly
afterwards.

With online services -- such as Overleaf -- or when using an
automatic tool -- such as \LaTeX MK -- all commands are executed
automatically. When you omit the \verb"\printbibliography" command,
its location will be decided by the template.

  \printbibliography[heading=bibintoc] %% Print the bibliography.

\chapter{Inserting the index}
After using the \verb"\makeindex" macro and loading the
\texttt{makeidx} package that provides additional indexing
commands, index entries can be created by issuing the \verb"\index"
command. \index{dummy text|(}It is possible to create ranged index
entries, which will encompass a span of text.\index{dummy text|)}
To insert complex typographic material -- such as $\alpha$
\index{alpha@$\alpha$} or \TeX{} \index{TeX@\TeX} --
into the index, you need to specify a text string, which will
determine how the entry will be sorted. It is also possible to
create hierarchal entries. \index{vehicles!trucks}
\index{vehicles!speed cars}

After typesetting the document, it is necessary to generate the
index by running
\begin{center}%
  \texttt{texindy -I latex -C utf8 -L }$\langle$\textit{locale}%
  $\rangle$\texttt{ \jobname.idx}
\end{center}
from the command line, where $\langle$\textit{locale}$\rangle$
corresponds to the main locale of your thesis -- such as
\texttt{english}, and then typesetting the document again.

The \texttt{texindy} command needs to be executed from within the
directory, where the \LaTeX\ source file is located. In Windows,
the command line can be opened in a directory by holding down the
\textsf{Shift} key and by clicking the right mouse button while
hovering the cursor over a directory. Select the \textsf{Open Command
Window Here} option in the context menu that opens shortly
afterwards.

With online services -- such as Overleaf -- the commands are
executed automatically, although the locale may be erroneously
detected, or the \texttt{makeindex} tool (which is only able to
sort entries that contain digits and letters of the English
alphabet) may be used instead of \texttt{texindy}. In either case,
the index will be ill-sorted.

  \makeatletter\thesis@blocks@clear\makeatother
  \phantomsection %% Print the index and insert it into the
  \addcontentsline{toc}{chapter}{\indexname} %% table of contents.
  \printindex

\appendix %% Start the appendices.
\chapter{An appendix}
Here you can insert the appendices of your thesis.

\end{document}
