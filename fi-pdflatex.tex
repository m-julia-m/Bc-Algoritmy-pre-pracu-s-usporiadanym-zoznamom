%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital,     %% The `digital` option enables the default options for the
               %% digital version of a document. Replace with `printed`
               %% to enable the default options for the printed version
               %% of a document.
%%  color,       %% Uncomment these lines (by removing the %% at the
%%               %% beginning) to use color in the printed version of your
%%               %% document
  oneside,     %% The `oneside` option enables one-sided typesetting,
               %% which is preferred if you are only going to submit a
               %% digital version of your thesis. Replace with `twoside`
               %% for double-sided typesetting if you are planning to
               %% also print your thesis. For double-sided typesetting,
               %% use at least 120 g/m² paper to prevent show-through.
  nosansbold,  %% The `nosansbold` option prevents the use of the
               %% sans-serif type face for bold text. Replace with
               %% `sansbold` to use sans-serif type face for bold text.
  nocolorbold, %% The `nocolorbold` option disables the usage of the
               %% blue color for bold text, instead using black. Replace
               %% with `colorbold` to use blue for bold text.
  lof,         %% The `lof` option prints the List of Figures. Replace
               %% with `nolof` to hide the List of Figures.
  lot,         %% The `lot` option prints the List of Tables. Replace
               %% with `nolot` to hide the List of Tables.
]{fithesis4}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=slovak, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, german, russian, czech, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    department  = Fakulta informatiky,
    author      = Júlia Michálková,
    gender      = f,
    advisor     = {Prof. RNDr. Ivana Černá, CSc.},
    title       = {Algoritmy pre prácu s usporiadaným zoznamom},
    TeXtitle    = {Algoritmy pre~prácu s~usporiadaným zoznamom},
    keywords    = {keyword1, keyword2, ...},
    TeXkeywords = {keyword1, keyword2, \ldots},
    abstract    = {%
      This is the abstract of my thesis, which can

      span multiple paragraphs.
    },
    thanks      = {%
      These are the acknowledgements for my thesis, which can

      span multiple paragraphs.
    },
    bib         = my-bibliography.bib,
    %% Remove the following line to use the JVS 2018 faculty logo.
    facultyLogo = fithesis-fi,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
\usepackage[acronym]{glossaries}          %% The `glossaries` package
\renewcommand*\glspostdescription{\hfill} %% contains helper commands
\loadglsentries{example-terms-abbrs.tex}  %% for typesetting glossaries
\makenoidxglossaries                      %% and lists of abbreviations.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{listings} %% Source code highlighting
\usepackage{indentfirst} %% Added by me Julka
\usepackage[ruled, vlined]{algorithm2e}

\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
\usepackage[babel]{csquotes} %% Context-sensitive quotation marks
\begin{document}
%% Uncomment the following lines (by removing the %% at the beginning)
%% and to print out List of Abbreviations and/or Glossary in your
%% document. Titles for these tables can be changed by replacing the
%% titles `Abbreviations` and `Glossary`, respectively.
%% \clearpage
%% \printnoidxglossary[title={Abbreviations}, type=\acronymtype]
%% \printnoidxglossary[title={Glossary}]

%% The \chapter* command can be used to produce unnumbered chapters:
\chapter*{Úvod}
%% Unlike \chapter, \chapter* does not update the headings and does not
%% enter the chapter to the table of contents. I we want correct
%% headings and a table of contents entry, we must add them manually:
\markright{\textsc{Úvod}}
\addcontentsline{toc}{chapter}{Úvod}

\chapter{Prehľadová kapitola}
Usporiadaný zoznam (order data structure) \cite{paper1_ordered_list}  je~dátová štruktúra, ktorá~uchováva úplné usporiadanie podliehajúce operáciám: Insert(X,~Y), Delete(X) a Order(X,~Y). Operácia Insert(X, Y) vkladá do~úplného usporiadanie nový prvok~Y bezprostredne za~prvok~X. Operácia Delete(X) odstraňuje z~úplného usporiadania prvok~X. Operácia Order(X,~Y) odpovedá, či v~úplnom usporiadaní prvok~X predchádza prvok~Y.

Cieľom tejto bakalárskej práce je popísať a~porovnať vybrané efektívne spôsoby implementácie usporiadaného zoznamu, konkrétne dátové štruktúry a~s~nimi spojené algoritmy z~vedeckých článkov \textit{Two~Simplified Algorithms for~Maintaining Order in~a~List} \cite{paper1_ordered_list} a~\textit{File Maintenance: When~in~Doubt, Change the~Layout!} \cite{paper2_file_maintenance}. Uvedené články sú veľmi stručné. Táto práca sa ich riešeniam preto venuje podrobnejšie, so~zámerom pomôcť čitateľovi jednoduchšie pochopiť fungovanie daných dátových štruktúr.

Súčasťou bakalárskej práce je implementácia popísanej dátovej štruktúry a~tvorba vizualizačného nástroja, ktorý demonštruje priebeh realizácie operácií Insert, Delete a~Order.

Jedno z~najefektívnejších riešení usporiadaného zoznamu pochádza už~z~roku~1988. Profesori Daniel D. Sleator a~Paul F. Dietz v článku \textit{Two~Algorithms for~Maintaining Order in~a~List} \cite{paper3_1988} popisujú dva rôzne algoritmy. Prvý algoritmus umožňuje vykonávať operácie Insert, Delete a~Order s~konštantnou asymptotickou amortizovanou časovou zložitosťou O(n). Druhý algoritmus umožňuje vykonávať všetky operácie s~konštantnou asymptotickou časovou zložitosťou O(n) v najhoršom prípade. Táto práca sa zameriava na~novšie riešenia, na~základe zhodnotenia odborníkov z~oblasti:
\uv{Známe optimálne riešenia od~Dietza a~Sealtora sú komplikované. Prezentujeme nové algoritmy, ktoré zodpovedajú medziam\footnote{Medze v tomto kontexte znamenajú časovú náročnosť operácií.} od~Dietza a~Sealtora. Naše riešenia sú jednoduché a~prezentujeme experimentálny dôkaz, ktorý napovedá, že~v~praxi fungujú lepšie.} \cite{paper1_ordered_list}

Návrh implementácie vychádza z~existujúceho vizualizéru\footnote{Dostupné na \url{ https://justforfuncoding.github.io/BITvisualization/}.} operácií  range update a~range query na~binárne indexovanom strome, ktorý tiež vznikol ako~súčasť bakalárskej práce \cite{Kridl2022thesis}. Vizualizér sa spúšťa vo~webovom prehliadači. Na~výstavbu stránky je použitý jazyk HTML5 v~kombinácii s~jazykom JavaScript. Pre~docielenie príjemnejšieho vzhľadu~a správneho zvýraznenia jednotlivých častí je použité rozšírenie CSS. Samotné dátové štruktúry sú naprogramované v~jazyku Python pre~jednoduchú transformáciu pseudokódov na~funkčný Python kód.


\chapter{Usporiadaný zoznam}

\textbf{Lineráne usporiadaná množina} je množina, na ktorej je definované úplné usporiadanie. Usporiadanie je binárna relácia, ktorá je reflexívna, tranzitívna a antisymetrická. Usporiadanie budeme označovať symbolom $<$. Usporiadanie je úplné, ak každé dva prvky množiny sú porovnateľné, tj. x<y alebo y<x.

V rámci ľubovoľnej množiny $M$ hovoríme, že prvok $x$ je \emph{priamy predchodca} prvku $y$, ak platí $x, y \in M, \nexists z \in M: (x < z < y)$, respektíve prvok $x$ je \emph{priamy nasledovník} prvku $y$, ak platí $x, y \in M, \nexists z \in M: (y < z < x)$.\\

\textbf{Usporiadaný zoznam} (order data structure) definujeme ako dátovú štruktúru, ktorá uchováva neprázdnu \textit{lineárne usporiadanú množinu objektov} $M$ a môžeme na nej vykonávať operácie:
\begin{enumerate}
    \item \textit{Insert(x, y)}: vkladá do množiny $M$ nový objekt $y$ ako priameho nasledovníka existujúceho objektu $x$ z množiny $M$. Po vykonaní operácie platí:
    \begin{compactitem}
        \item $x < y$
        \item $\forall z \in M: (z < x) \implies (z < y) $
        \item $\forall z \in M: (x < z) \land (z \neq y) \implies (y < z)$
    \end{compactitem}

    \item \textit{Delete(x)}: odstraňuje z množiny $M$ existujúci objekt $x$.
    \item \textit{Order(x, y)}: odpovedá, či $x$ je predchodca objektu $y$ pre existujúce objekty $x$ aj $y$ z množiny $M$.
\end{enumerate}
Predpokladáme, že:
\begin{compactitem}
    \item Štruktúra je inicializovaná operáciou \textit{Initialize(x)} a po inicializácii množina $M$ obsahuje objekt x.
    \item Štruktúra nikdy neostane s prázdnou množinou objektov.\\
\end{compactitem}

Príklad 1:
Máme usporiadaný zoznam s množinou objektov $A < B < C$ a vykonávame na ňom nasledovné operácie v poradí v akom sú uvedené:\\
\begin{table}
\begin{tabularx}{\textwidth}{| l | l | l |}
    % \toprule
    operácia & návratová hodnota & množina objektov po operácii \\
    \midrule
    $Insert(B, D)$ &  & $A < B < D < C$\\
    $Insert(B, E)$ &  & $A < B < E < D < C$\\
    $Order(D, E)$ & $false$ & $A < B < E < D < C$\\
    $Order(E, C)$ & $true$ & $A < B < E < D < C$\\
    $Delete(A)$ &  & $B < E < D < C$\\
    $Insert(B, C)$ & \multicolumn{2}{l|}{\textit{chyba/ nedefinované chovanie (množina už obsahuje C)}}\\
    $Order(A, B)$ & \multicolumn{2}{l|}{\textit{chyba/ nedefinované chovanie (množina neobsahuje A)}}\\
    $Delete(F)$ & \multicolumn{2}{l|}{\textit{chyba/ nedefinované chovanie (množina neobsahuje F)}}\\
    % \bottomrule
  \end{tabularx}
\end{table}

% \chapter{Intuitívna implementácia poľom}
% Jednou z možností implementácie usporiadaného zoznamu je ukladať objekty v poli, pričom poradie prvkov v poli odpovedá ich usporiadaniu od najmenšieho po najväčší.

% Operácia $Insert(x, y)$ vkladá nový objekt $y$ do poľa hneď za $x$. Elementy poľa napravo od $x$ musíme posunúť o jednu pozíciu doprava. Preto má táto operácia časovú zložitosť $O(n)$.

% Operácia $Delete(x)$ odstraňuje objekt $x$ z poľa. 
% Aby sme zaplnili prázdne miesto, musíme všetky objekty v poli napravo od $x$ posunúť o jednu pozíciu doľava. Operácia má preto časovú zložitosť $O(n)$.

% Operácii $Order(x, y)$ stačí porovnať indexy prvkov $x$ a $y$. Objekt uložený v poli na nižšom indexe predchádza prvok uložený na vyššom indexe. Preto platí $Order(x, y) \iff index(x) < index(y)$.


\chapter{Spájaný zoznam}

Jednou z možností implementácie usporiadaného zoznamu je ukladať objekty v obojsmerne spájanom zozname (doubly linked list). Každý uzol spájaného zoznamu reprezentuje jeden objekt a má odkaz na svojho priameho nasledovníka a priameho predchodcu. Poradie v akom sú objekty uložené v spájanom zozname odpovedá ich usporiadaniu od najmenšieho po najväčší.

Operácia $Insert(x, y)$ vkladá nový objekt $y$ do zoznamu ako nasledovníka $x$. Stačí nastaviť nové vzťahy priamych nasledovníkov a predchodcov pre uzol $y$ a uzly s ním susediace. Operácia má preto časovú zložitosť $O(1)$.

Operácia $Delete(x)$ odstraňuje $x$ zo zoznamu. Opäť stačí nastaviť nové vzťahy priamych prechodcov a následníkov pre uzly susediace s $x$. Operácia má preto časovú zložitosť $O(1)$.

Operácia $Order(x, y)$ odpovedá, či $x < y$, teda či sa $x$ nachádza bližšie k začiatku spájaného zoznamu než $y$. Postupne prechádza zoznam, kým nenájde uzol $x$ alebo $y$. Ak ako prvý nájde uzol $x$, platí $x < y$. V opačnom prípade $x > y$.

\SetAlgorithmName{Algoritmus}{Zoznam algoritmov} 

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na nový objekt),\\
linkedList (spájaný zoznam objektov)}
\hline\vspace{0.2em}
y.next \leftarrow x.next\;
\If {y.next == null}
{
    linkedList.tail \leftarrow y\;
}
\Else
{
    y.next.prev \leftarrow y\;
}
y.prev \leftarrow x\;
x.next \leftarrow y\;
\caption{Insert na spájanom zozname}
\end{algorithm}

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
linkedList (spájaný zoznam objektov)}
\hline\vspace{0.2em}
\If {x.prev == null}
{
    linkedList.head $\leftarrow$ x.next\;
}
\Else
{
    x.prev.next $\leftarrow$ x.next\;
}
\If {x.next == null}
{
    linkedList.tail \leftarrow x.prev\;
}
\Else
{
    x.next.prev $\leftarrow$ x.prev\;
}
\caption{Delete na spájanom zozname}
\end{algorithm}

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na objekt v zozname),\\
linkedList (spájaný zoznam objektov)}
\Output{pravdivostná hodnota (x > y)}
\hline\vspace{0.2em}
node $\leftarrow$ linkedList.head\;
\While{node != null}
{
    \If{node == x}
    {
        \Return{true}\;
    }
    \If{node == y}
    {
        \Return {false}\;
    }
    node $\leftarrow$ node.next\;
}
\caption{Order na spájanom zozname}
\end{algorithm}


\chapter{Spájaný zoznam s tagmi}

V tejto kapitole sa budeme venovať riešeniu z článku \textit{Two Simplified Algorithms for Maintaining Order in a List} \cite{paper1_ordered_list}.

Táto implementácia tiež vychádza z obojsmerne spájaného zoznamu, v ktorom poradie objektov v zozname zodpovedá ich usporiadaniu. Každý objektu v zozname má navyše priradený \textit{tag}. Tagy sú celé čísla a platí $x < y \iff x.tag < y.tag$, teda každý objekt má vyšší tag než jeho predchodca. Tagy v rámci zoznamu preto rastú smerom k poslednému objektu. Hodnoty tagov sú obmedzené na interval $[0, u]$. Tagy nám zjednodušujú operáciu Order (stačí porovnať tagy prvkov), no prinášajú nové otázky:
\begin{compactenum}
  \item voľba hornej hranice intervalu tagov $u$
  \item stratégia priraďovania tagov pre nové objekty
  \item riešenie situácie, kedy pre nový objekt nemáme dostupný tag (rozdiel tagov jeho predchodcu a následníka je 1).
\end{compactenum}

\subsection*{Analógia s binárnym stromom}
Keď zapisujeme tagy v binárnej sústave, môžeme si štruktúru predtaviť ako prefixový strom, ktorého listami sú objekty a cesta od koreňa k listu odpovedá tagu dosiahnutého objektu, viď obrázok nižšie.

\includegraphics[width=\textwidth]{graphics/graphviz.png}

Pri implementácii nám stačí uchovávať spájaný zoznam objektov, predstava virtuálneho stromu nám len pomáha pri teoretickom skúmaní štruktúry, nazývame ho preto \textit{virtuálny strom}. Keďze každý bit tagu je buď $0$ alebo $1$, je tento strom binárny a má hĺbku odpovedajúcu dĺžke reťazca binárneho zápisu tagu, t.j. $\log{u}$.

Každý vnútorný uzol tohoto stromu identifikuje \textit{rozhranie tagov}, ktorým je prefixom. Toto rozhranie tagov odpovedá podzoznamu (sublist) objektov, ktoré sú listami dosiahnuteľnými z tohoto uzlu. Každý objekt patrí do $\log{u}$ takýchto rozhraní tagov.

\subsection*{Rekonštrukcia zoznamu (rebuild)}

Aktuálny počet objektov v zozname označujeme n. Počet objektov pri poslednej \textit{rekonštrukcii (rebuild)} zoznamu označujeme N. Rekonštrukciu zoznamu realizujeme, keď je porušený \textit{invariant 1:} $N/2 <= n <= 2N$.

Pri rekonštrukcii priraďujeme $N = n$. Na základe nového $N$ priraďujeme $u = N^c$, kde $c$ je konštanta. V rámci tejto práce pracujeme s $c = 2$, takže $u = N^2$. Následne prechádzame zoznam objektov a priraďujeme im nové tagy z intervalu $[0, u]$ s rovnomernými medzerami.

Príklad 2.:
Tabuľka nižšie ukazuje, ako sa menia hodnoty $n, N,$ a $u$ pri vykonaní operácií:
\begin{table}
\begin{tabularx}{\textwidth}{| l | l | l | l | l | l}
    % \toprule
    operácia & usporiadanie & $n$ & $N$ & $u$ & poznámka \\
    \midrule
    $Initialize(X)$ & $X$ & $1$ & $1$ & $2$ & inicializácia\\
    $Insert(X, A)$ & $X < A$ & $2$ & $2$ & $4$ & rekonštrukcia\\
    $Insert(A, B)$ & $X < A < B$ & $3$ & $2$ & $4$ & \\
    $Insert(B, C)$ & $X < A < B < C$ & $4$ & $2$ & $4$ & \\
    $Insert(X, Y)$ & $X < Y < A < B < C$ & $5$ & $5$ & $25$ & rekonštrukcia\\
    $Delete(C)$ & $X < Y < A < B$ & $4$ & $5$ & $25$ & \\
    $Delete(B)$ & $X < Y < A $ & $3$ & $5$ & $25$ & \\
    $Delete(A)$ & $X < Y$ & $2$ & $2$ & $4$ & rekonštrukcia\\
    % \bottomrule
  \end{tabularx}
\end{table}


\section{Insert(x, y)}

Keď vkladáme do zoznamu nový objekt $y$ medzi objekty $x$ a $z$, musíme mu priradiť tag splňajúci $x.tag < y.tag < z.tag$ (respektíve $x.tag < y.tag <= u$, ak $y$ je posledný prvok zoznamu).
Pokiaľ nie je dostupný žiadny tag z daného rozpätia (rozdiel medzi tagmi $x$ a $z$ je 1, respektíve $x.tag = u$), musíme pretagovať časť zoznamu (relabeling).

Ak je po vložení nového objektu porušený invariant $N/2 <= n <= 2N$, realizujeme rekonštrukciu zoznamu.

\subsection{Stratégia voľby tagov}

\textit{Two Simplified Algorithms for Maintaining Order in a List} \cite{paper1_ordered_list} experimentálne porovnáva 2 stratégie výberu nového tagu:
1. Po sebe idúce tagy (consecutive inserts): tag nového objektu je o 1 vyšší než tag jeho predchodcu.
2. Priemerované tagy (average inserts): tag nového objektu je priemer jeho susedov.
Pri stratégii po sebe idúcich tagov musíme pretagovať menší interval každý druhý insert. Pri stratégii priemerovaných tagov musíme pretagovať väčšie intervaly, no menej často.
Používanie priemerovaných tagov sa ukázalo o konštantu rýchlejšie než po sebe idúce tagy. Časová náročnosť tohoto riešenia však nie je závislá na stratégii voľby tagov. 

\subsection{Pretagovanie (relabeling)}
Pretagovanie pri vkladaní objektu $y$ za $x$ pozostáva z 2 častí:
\begin{compactenum}
    \item Nájsť najmenšie rozhranie tagov, do ktorého patrí $x$ a \textit{nepreteká}.
    \item Priradenie nových tagov objektom v nájdenom rozhraní.
\end{compactenum}
Pri hľadaní najmenšieho rozhrania, ktoré nepreteká, postupujeme vo virtuálnom strome od listu objektu $x$ smerom ku koreňu. Skúmané rozhrania tagov teda rastú geometricky, ich veľkosť odpovedá $2^i$, kde $i$ je vzdialenosť od listov vo virtuálnom strome. Zastavíme sa na prvom rozhraní, ktoré nepreteká.
Hovoríme, že rozhranie tagov \textit{preteká (overflow)}, ak je jeho \textit{hustota zaplnenia (density)} vyššia ako \textit{hranica pretečenia (overflow threshold)}. \textit{Hustota zaplenia} rozhrania tagov je podiel využitých tagov z tohoto rozhrania. Hustotu zaplnenia počítame prechádzaním objektov v tomto rozhraní. Hranicu pretečenia počítame nasledovne:
\begin{compactenum}
    \item Pre rozhranie tagov s veľkosťou $2^0 = 1$ (listy vo virtuálnom strome) je hranica pretečenia $T_0 = 1$.
    \item Inak, pre rozhrania veľkosti $2^i$, $T_i = T_{i-1} / T = T^{-i}$.
\end{compactenum}
Vďaka invariantu $N/2 <= n <= 2N$ koreň virtuálneho stromu nikdy nepretečie, takže vždy môžeme v najhoršom prípade pretagovať celý zoznam.
Po nájdení rozhrania, ktoré chceme pretagovať, priraďujeme objektom z tohoto rozhrania nové tagy, ktoré sú rovnomerne rozdistribuované v rámci daného rozhrania. Nový objekt $y$ môžeme pridať do zoznamu už pri priraďovaní nových tagov.

\section{Delete(x)}
Pri odstraňovaní objektu stačí nastaviť nové vzťahy priameho prechodcu/následníka pre uzly susediace s $x$.

Ak je po odstránení porušený invariant $N/2 <= n <= 2N$, realizujeme rekonštrukciu zoznamu.

\section{Order(x, y)}
K rozhodnutiu, či $x$ je predchodcom $y$, nám pomáhajú pridané tagy. Platí $x.tag < y.tag \iff x < y$, teda len porovnávame tagy $x$ a $y$.



\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{linkedList (spájaný zoznam objektov),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu),\\
u (horná hranicca tagov)}
\hline\vspace{0.2em}
N \leftarrow n\;

u \leftarrow N^2\;

tagOffset \leftarrow u / n\; \tcc*[h]{floored division}

tag \leftarrow 0\;

\ForEach {node in linkedList}
{
    node.tag \leftarrow tag\;
    
    tag \leftarrow tag + tagOffset\;
}

\caption{Rebuild/rekonštrukcia spájaného zoznamu s tagmi}
\end{algorithm}

\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na nový objekt),\\
linkedList (spájaný zoznam objektov s tagmi),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu),\\
u (horná hranicca tagov)}
\hline\vspace{0.2em}
z \leftarrow x.next\;

\If{(z == null and x.tag == u) or (x.tag + 1 == z.tag)}
{
    Relabel(x)\;
}

y.tag \leftarrow ChooseNewTagAfter(x)\;

y.next \leftarrow x.next\;
\If {y.next == null}
{
    linkedList.tail \leftarrow y\;
}
\Else
{
    y.next.prev \leftarrow y\;
}
y.prev \leftarrow x\;
x.next \leftarrow y\;


n \leftarrow n + 1\;

\If{!( N/2 <= n <= 2N)}
{
    Rebuild()\;
}
\caption{Insert na spájanom zozname s tagmi}
\end{algorithm}


\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname, za ktorým cheme vybrať tag)}
\Output{tag pre nový objekt vkladaný za x}
\hline\vspace{0.2em}
minTag \leftarrow x.tag + 1\;

maxTag \leftarrow u\;

\If {x.next != null}
{
    maxTag \leftarrow x.next.tag - 1\;
}

\Return {(minTag + maxTag) / 2}; \tcc{floored division}
\caption{ChooseNewTag na spájanom zozname s tagmi}
\end{algorithm}


\begin{algorithm}
\SetKwInOut{Input}{input}
\Input{x (ukazateľ na objekt v zozname),\\
linkedList (spájaný zoznam objektov),\\
n (počet objektov v zozname),\\
N (počet objektov pri poslednej rekonštrukcii zoznamu)}
\hline\vspace{0.2em}
\If {x.prev == null}
{
    linkedList.head $\leftarrow$ x.next\;
}
\Else
{
    x.prev.next $\leftarrow$ x.next\;
}
\If {x.next == null}
{
    linkedList.tail \leftarrow x.prev\;
}
\Else
{
    x.next.prev $\leftarrow$ x.prev\;
}

n \leftarrow n - 1\;

\If{!( N/2 <= n <= 2N)}
{
    Rebuild()\;
}
\caption{Delete na spájanom zozname s tagmi}
\end{algorithm}

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{x (ukazateľ na objekt v zozname),\\
y  (ukazateľ na objekt v zozname)}
\Output{pravdivostná hodnota (x > y)}
\hline\vspace{0.2em}
\Return {x.tag < y.tag}\;
\caption{Order na spájanom zozname s tagmi}
\end{algorithm}


\chapter{These are}
\section{the available}
\subsection{sectioning}
\subsubsection{commands.}
\paragraph{Paragraphs and}
\subparagraph{subparagraphs are available as well.}
Inside the text, you can also use unnumbered lists,
\begin{itemize}
  \item such as
  \item this one
  \begin{itemize}
    \item     and they can be nested as well.
    \item[>>] You can even turn the bullets into something fancier,
    \item[\S] if you so desire.
  \end{itemize}
\end{itemize}
Numbered lists are
\begin{enumerate}
  \item very
  \begin{enumerate}
    \item similar
  \end{enumerate}
\end{enumerate}
and so are description lists:
\begin{description}
  \item[Description list]
    A list of terms with a description of each term
\end{description}
The spacing of these lists is geared towards paragraphs of text.
For lists of words and phrases, the \textsf{paralist} package
offers commands
\begin{compactitem}
  \item that
  \begin{compactitem}
    \item are
    \begin{compactitem}
      \item better
      \begin{compactitem}
        \item suited
      \end{compactitem}
    \end{compactitem}
  \end{compactitem}
\end{compactitem}
\begin{compactenum}
  \item to
  \begin{compactenum}
    \item this
    \begin{compactenum}
      \item kind of
      \begin{compactenum}
        \item content.
      \end{compactenum}
    \end{compactenum}
  \end{compactenum}
\end{compactenum}
The \textsf{amsthm} package provides the commands necessary for the
typesetting of mathematical definitions, theorems, lemmas and
proofs.

%% We will define several mathematical sectioning commands.
\newtheorem{theorem}{Theorem}[section] %% The numbering of theorems
                               %% will be reset after each section.
\newtheorem{lemma}[theorem]{Lemma}         %% The numbering of lemmas
\newtheorem{corollary}[theorem]{Corollary} %% and corollaries will
                               %% share the counter with theorems.
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\begin{theorem}
  This is a theorem that offers a profound insight into the
  mathematical sectioning commands.
\end{theorem}
\begin{theorem}[Another theorem]
  This is another theorem. Unlike the first one, this theorem has
  been endowed with a name.
\end{theorem}
\begin{lemma}
  Let us suppose that $x^2+y^2=z^2$. Then
  \begin{equation}
    \biggl\langle u\biggm|\sum_{i=1}^nF(e_i,v)e_i\biggr\rangle
    =F\biggl(\sum_{i=1}^n\langle e_i|u\rangle e_i,v\biggr).
  \end{equation}
\end{lemma}
\begin{proof}
  $\nabla^2 f(x,y)=\frac{\partial^2f}{\partial x^2}+
   \frac{\partial^2f}{\partial y^2}$.
\end{proof}
\begin{corollary}
  This is a corollary.
\end{corollary}
\begin{remark}
  This is a remark.
\end{remark}

\chapter{Floats and references}
\begin{figure}
  \begin{center}
    %% PNG and JPG images can be inserted into the document as well,
    %% but their resolution needs to be adequate. The minimum is
    %% about 100 pixels per 1 centimeter or 300 pixels per 1 inch.
    %% That means that a JPG or PNG image typeset at 4 × 4 cm should
    %% be 400 × 400 px large at the bare minimum.
    %%
    %% The optimum is about 250 pixels per 1 centimeter or 600
    %% pixels per 1 inch. That means that a JPG or PNG image typeset
    %% at 4 × 4 cm should be 1000 × 1000 px large or larger.
    \includegraphics[width=6.3cm]{fithesis/logo/mu/fithesis-base-english-color}
  \end{center}
  \caption{The logo of \acrlong{MU} at 6.3\,cm}
  \label{fig:mulogo1}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{minipage}{.5\textwidth}
      \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base-english-color}
    \end{minipage}
    \hfill  % Fill the horizontal space between the images
    \begin{minipage}{.33\textwidth}
      \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base-english-color} \\[1em]
      \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base-english-color}
    \end{minipage}
  \end{center}
\caption{The logo of \acrlong{MU} at $\frac12$ and
    $\frac13$ of text width}
  \label{fig:mulogo2}
\end{figure}

\begin{table}
  \begin{tabularx}{\textwidth}{lllX}
    \toprule
    Day & Min Temp & Max Temp & Summary \\
    \midrule
    Monday & $13^{\circ}\mathrm{C}$ & $21^\circ\mathrm{C}$ & A
    clear day with low wind and no adverse current advisories. \\
    Tuesday & $11^{\circ}\mathrm{C}$ & $17^\circ\mathrm{C}$ & A
    trough of low pressure will come from the northwest. \\
    Wednesday & $10^{\circ}\mathrm{C}$ &
    $21^\circ\mathrm{C}$ & Rain will spread to all parts during the
    morning. \\
    \bottomrule
  \end{tabularx}
  \caption{A weather forecast}
  \label{tab:weather}
\end{table}

The logo of \gls{MU} is shown in Figure \ref{fig:mulogo1} and
Figure \ref{fig:mulogo2} at pages \pageref{fig:mulogo1} and
\pageref{fig:mulogo2}. The weather forecast is shown in Table
\ref{tab:weather} at page \pageref{tab:weather}. The following
chapter is Chapter \ref{chap:matheq} and starts at page
\pageref{chap:matheq}.  Items \ref{item:star1}, \ref{item:star2},
and \ref{item:star3} are starred in the following list:
\begin{compactenum}
  \item some text
  \item some other text
  \item $\star$ \label{item:star1}
  \begin{compactenum}
    \item some text
    \item $\star$ \label{item:star2}
    \item some other text
    \begin{compactenum}
      \item some text
      \item some other text
      \item yet another piece of text
      \item $\star$ \label{item:star3}
    \end{compactenum}
    \item yet another piece of text
  \end{compactenum}
  \item yet another piece of text
\end{compactenum}
If your reference points to a place that has not yet been typeset,
the \verb"\ref" command will expand to \textbf{??} during the first
run of
\texttt{pdflatex \jobname.tex}
and a second run is going to be needed for the references to
resolve. With online services -- such as \Gls{Overleaf} -- this is
performed automatically.

\chapter{Mathematical equations}
\label{chap:matheq}
\TeX{} comes pre-packed with the ability to typeset inline
equations, such as $\mathrm{e}^{ix}=\cos x+i\sin x$, and display
equations, such as \[
  \mathbf{A}^{-1} = \begin{bmatrix}
  a & b \\ c & d \\
  \end{bmatrix}^{-1} =
  \frac{1}{\det(\mathbf{A})} \begin{bmatrix}
  \,\,\,d & \!\!-b \\ -c & \,a \\
  \end{bmatrix} =
  \frac{1}{ad - bc} \begin{bmatrix}
  \,\,\,d & \!\!-b \\ -c & \,a \\
  \end{bmatrix}.
\] \LaTeX{} defines the automatically numbered \texttt{equation}
environment:
\begin{equation}
  \gamma Px = PAx = PAP^{-1}Px.
\end{equation}
The package \textsf{amsmath} provides several additional
environments that can be used to typeset complex equations:
\begin{enumerate}
  \item An equation can be spread over multiple lines using the
    \texttt{multline} environment:
    \begin{multline}
      a + b + c + d + e + f + b + c + d + e + f + b + c + d + e +
f \\
      + f + g + h + i + j + k + l + m + n + o + p + q
    \end{multline}

  \item Several aligned equations can be typeset using the
    \texttt{align} environment:
    \begin{align}
              a + b &= c + d     \\
                  u &= v + w + x \\[1ex]
      i + j + k + l &= m
    \end{align}

  \item The \texttt{alignat} environment is similar to
    \texttt{align}, but it doesn't insert horizontal spaces between
    the individual columns:
    \begin{alignat}{2}
      a + b + c &+ d       &   &= 0 \\
              e &+ f + g   &   &= 5
    \end{alignat}

  \item Much like chapter, sections, tables, figures, or list
    items, equations -- such as \eqref{eq:first} and
    \eqref{eq:mine} -- can also be labeled and referenced:
    \begin{alignat}{4}
      b_{11}x_1 &+ b_{12}x_2  &  &+ b_{13}x_3  &  &             &
        &= y_1,                   \label{eq:first} \\
      b_{21}x_1 &+ b_{22}x_2  &  &             &  &+ b_{24}x_4  &
        &= y_2. \tag{My equation} \label{eq:mine}
    \end{alignat}

  \item The \texttt{gather} environment makes it possible to
    typeset several equations without any alignment:
    \begin{gather}
      \psi = \psi\psi, \\
      \eta = \eta\eta\eta\eta\eta\eta, \\
      \theta = \theta.
    \end{gather}

  \item Several cases can be typeset using the \texttt{cases}
    environment:
    \begin{equation}
      |y| = \begin{cases}
        \phantom-y & \text{if }z\geq0, \\
                -y & \text{otherwise}.
      \end{cases}
    \end{equation}
\end{enumerate}
For the complete list of environments and commands, consult the
\textsf{amsmath} package manual\footnote{
  See \url{http://mirrors.ctan.org/macros/latex/required/amsmath/amsldoc.pdf}.
  The \texttt{\textbackslash url} command is provided by the
  package \textsf{url}.
}.

\chapter{\textnormal{We \textsf{have} \texttt{several} \textsc{fonts}
  \textit{at} \textbf{disposal}}}
The serified roman font is used for the main body of the text.
\textit{Italics are typically used to denote emphasis or
quotations.} \texttt{The teletype font is typically used for source
code listings.} The \textbf{bold}, \textsc{small-caps} and
\textsf{sans-serif} variants of the base roman font can be used to
denote specific types of information.

\tiny We \scriptsize can \footnotesize also \small change \normalsize
the \large font \Large size, \LARGE although \huge it \Huge
is \huge usually \LARGE not \Large necessary.\normalsize

A wide variety of mathematical fonts is also available, such as: \[
  \mathrm{ABC}, \mathcal{ABC}, \mathbf{ABC}, \mathsf{ABC},
  \mathit{ABC}, \mathtt{ABC}
\] By loading the \textsf{amsfonts} packages, several additional
fonts will become available: \[
  \mathfrak{ABC}, \mathbb{ABC}
\] Many other mathematical fonts are available\footnote{
  See \url{http://tex.stackexchange.com/a/58124/70941}.
}.

\chapter{Inserting the bibliography}

After linking a bibliography data\-base files to the document using
the \verb"\"\texttt{thesis\discretionary{-}{}{}setup\{bib\discretionary{=}{=}{=}%
\{\textit{file1},\textit{file2},\,\ldots\,\}\}} command, you can
start citing the entries. This is just dummy text
\parencite{paper1_ordered_list} lightly sprinkled with citations
\parencite[p.~123]{paper1_ordered_list}. Several sources can be cited at
once: \cite{paper1_ordered_list,paper2_file_maintenance,paper2_file_maintenance}.
\citetitle{paper1_ordered_list} was written by \citeauthor{paper1_ordered_list} in
\citeyear{paper1_ordered_list}. We can also produce \textcite{paper1_ordered_list}%
\ or %% Let us define a compound command:
\def\citeauthoryear#1{(\textcite{#1},~\citeyear{#1})}%
\citeauthoryear{paper2_file_maintenance}%
. The full bibliographic citation is:
\emph{\fullcite{paper1_ordered_list}}. We can easily insert a bibliographic
citation into the footnote\footfullcite{paper1_ordered_list}.

The \verb"\nocite" command will not generate any
output\nocite{paper1_ordered_list}, but it will insert its arguments into
the bibliography. The \verb"\nocite{*}" command will insert all the
records in the bibliography database file into the bibliography.
Try uncommenting the command
%%\nocite{*}
and watch the bibliography section come apart at the seams.

When typesetting the document for the first time, citing a
\texttt{work} will expand to [\textbf{work}] and the
\verb"\printbibliography" command will produce no output. It is now
necessary to generate the bibliography by running \texttt{biber
\jobname.bcf} from the command line and then by typesetting the
document again twice. During the first run, the bibliography
section and the citations will be typeset, and in the second run,
the bibliography section will appear in the table of contents.

The \texttt{biber} command needs to be executed from within the
directory, where the \LaTeX\ source file is located. In Windows,
the command line can be opened in a directory by holding down the
\textsf{Shift} key and by clicking the right mouse button while
hovering the cursor over a directory.  Select the \textsf{Open
Command Window Here} option in the context menu that opens shortly
afterwards.

With online services -- such as Overleaf -- or when using an
automatic tool -- such as \LaTeX MK -- all commands are executed
automatically. When you omit the \verb"\printbibliography" command,
its location will be decided by the template.

  \printbibliography[heading=bibintoc] %% Print the bibliography.

\chapter{Inserting the index}
After using the \verb"\makeindex" macro and loading the
\texttt{makeidx} package that provides additional indexing
commands, index entries can be created by issuing the \verb"\index"
command. \index{dummy text|(}It is possible to create ranged index
entries, which will encompass a span of text.\index{dummy text|)}
To insert complex typographic material -- such as $\alpha$
\index{alpha@$\alpha$} or \TeX{} \index{TeX@\TeX} --
into the index, you need to specify a text string, which will
determine how the entry will be sorted. It is also possible to
create hierarchal entries. \index{vehicles!trucks}
\index{vehicles!speed cars}

After typesetting the document, it is necessary to generate the
index by running
\begin{center}%
  \texttt{texindy -I latex -C utf8 -L }$\langle$\textit{locale}%
  $\rangle$\texttt{ \jobname.idx}
\end{center}
from the command line, where $\langle$\textit{locale}$\rangle$
corresponds to the main locale of your thesis -- such as
\texttt{english}, and then typesetting the document again.

The \texttt{texindy} command needs to be executed from within the
directory, where the \LaTeX\ source file is located. In Windows,
the command line can be opened in a directory by holding down the
\textsf{Shift} key and by clicking the right mouse button while
hovering the cursor over a directory. Select the \textsf{Open Command
Window Here} option in the context menu that opens shortly
afterwards.

With online services -- such as Overleaf -- the commands are
executed automatically, although the locale may be erroneously
detected, or the \texttt{makeindex} tool (which is only able to
sort entries that contain digits and letters of the English
alphabet) may be used instead of \texttt{texindy}. In either case,
the index will be ill-sorted.

  \makeatletter\thesis@blocks@clear\makeatother
  \phantomsection %% Print the index and insert it into the
  \addcontentsline{toc}{chapter}{\indexname} %% table of contents.
  \printindex

\appendix %% Start the appendices.
\chapter{An appendix}
Here you can insert the appendices of your thesis.

\end{document}
